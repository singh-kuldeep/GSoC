--- module-cyclocopter.cc	2016-06-24 03:36:57.270915138 +0530
+++ module-cyclocopter_kuldeep.cc	2016-06-24 03:37:12.538915447 +0530
@@ -49,7 +49,7 @@
 /* CyclocopterInflow - begin */
 
 /* Base class for cycloidal rotor  inflow models:
- * all models a derived from this class
+ * all models are derived from this class
 */
 
 class CyclocopterInflow
@@ -68,6 +68,7 @@
 	doublereal dArea;		// Cylinder longitudinal area
 
 	doublereal dKappa;		// Hover correction coefficient
+	int 	   nStreamtube; // Number of incoming streamtubes from freestream   	
 
 	DriveOwner Weight;
 	doublereal dWeight;
@@ -314,7 +315,7 @@
 	return true;
 }
 
-static bool
+static bool 
 ReadUniform(DataManager* pDM,
 	MBDynParser& HP,
 	unsigned int uLabel,
@@ -324,7 +325,7 @@
 	DriveCaller *& pdW,
 	doublereal& dOmegaFilter,
 	doublereal& dKappa,
-	doublereal& dDeltaT)
+	doublereal& dDeltaT, int& nStreamtube)
 {
 	bFlagAve = HP.GetYesNoOrBool();
 
@@ -396,6 +397,18 @@
 		dDeltaT = 0.;
 	}
 
+	nStreamtube = 1.;
+	if (HP.IsKeyWord("streamtubes")) {
+		nStreamtube = HP.GetReal();
+		if (nStreamtube <= 0) {
+			silent_cerr("Illegal null or negative number of"
+				"streamtubes" << uLabel
+				<< " at line " << HP.GetLineData()
+				<< std::endl);
+			return false;
+		}
+	}
+
 	return true;
 }
 
@@ -449,7 +462,6 @@
 	virtual Mat3x3 GetRRotor(const Vec3& X) const {
 		return ::Zero3x3;
 	}
-
 };
 
 CyclocopterNoInflow::CyclocopterNoInflow(unsigned int uL, const DofOwner* pDO,
@@ -671,6 +683,7 @@
 "		[ , kappa , <hover_correction_coefficient> ]\n"
 "		[ , timestep , <time_step> ]\n"
 "		[ , <output_data> ]\n"
+"		[ , streamtubes , <Number_of_incoming_stream_tubes> ]\n"
 "	;\n"
 			<< std::endl);
 
@@ -689,7 +702,7 @@
 	DriveCaller *pdW = 0;
 	doublereal dOmegaFilter;
 	doublereal dDeltaT;
-	if (!ReadUniform(pDM, HP, uLabel, bFlagAverage, dRadius, dSpan, pdW, dOmegaFilter, dKappa, dDeltaT)) {
+	if (!ReadUniform(pDM, HP, uLabel, bFlagAverage, dRadius, dSpan, pdW, dOmegaFilter, dKappa, dDeltaT,nStreamtube)) {
 		throw ErrGeneric(MBDYN_EXCEPT_ARGS);
 	}
 
@@ -990,7 +1003,7 @@
 	DriveCaller *pdW = 0;
 	doublereal dOmegaFilter;
 	doublereal dDeltaT;
-	if (!ReadUniform(pDM, HP, uLabel, bFlagAverage, dRadius, dSpan, pdW, dOmegaFilter, dKappa, dDeltaT)) {
+	if (!ReadUniform(pDM, HP, uLabel, bFlagAverage, dRadius, dSpan, pdW, dOmegaFilter, dKappa, dDeltaT, nStreamtube)) {
 		throw ErrGeneric(MBDYN_EXCEPT_ARGS);
 	}
 
@@ -1166,6 +1179,7 @@
 	return WorkVec;
 }
 
+
 void
 CyclocopterUniform2D::AddForce(const Elem *pEl, const StructNode *pNode, const Vec3& F, const Vec3& M, const Vec3& X)
 {
@@ -1217,6 +1231,9 @@
 
 */
 
+
+
+
 class CyclocopterPolimi
 : virtual public Elem, public CyclocopterInflow {
 protected:
@@ -1318,7 +1335,7 @@
 	if (HP.IsKeyWord("help")) {
 		silent_cout(
 "									\n"
-"Module: 	Cyclocopter						\n"
+"Module: 	Cyclocopter_kuldeep						\n"
 "Author: 	Pierangelo Masarati <pierangelo.masarati@polimi.it>	\n"
 "based on work by							\n"
 "		Mattia Mattaboni <mattia.mattaboni@mail.polimi.it>	\n"
@@ -1361,7 +1378,7 @@
 	DriveCaller *pdW = 0;
 	doublereal dOmegaFilter;
 	doublereal dDeltaT;
-	if (!ReadUniform(pDM, HP, uLabel, bFlagAverage, dRadius, dSpan, pdW, dOmegaFilter, dKappa, dDeltaT)) {
+	if (!ReadUniform(pDM, HP, uLabel, bFlagAverage, dRadius, dSpan, pdW, dOmegaFilter, dKappa, dDeltaT, nStreamtube)) {
 		throw ErrGeneric(MBDYN_EXCEPT_ARGS);
 	}
 
@@ -1372,6 +1389,10 @@
 	dArea = 2*dRadius*dSpan;
 	Weight.Set(pdW);
 
+
+silent_cout("Rotor(" << GetLabel() << "): "
+			"delay > 1.0; using 1.0" << std::endl);
+
 	SetFilterCoefficients(dOmegaFilter, dDeltaT);
 }
 
@@ -1553,6 +1574,400 @@
 
 /* CyclocopterPolimi - end */
 
+
+
+
+/* CyclocopterDMST - begin */
+/*
+
+The induced velocity is opposite to
+the force generated by the rotor in the plane
+perdendicular to the rotor rotation axis. The
+rotor reference must have direction 1 aligned
+with the rotor rotation axis!
+The inflow velocity distribution is constant along
+the cylinder span and is function of r:
+Vi(r) = Kc*cos((pi/2)*(r/R)) + Ks*sin(pi*(r/R))
+where the cofficients Kc and Ks are based on the
+momentum theory
+
+*/
+
+class CyclocopterDMST
+: virtual public Elem, public CyclocopterInflow {
+protected:
+	Mat3x3 RRotor;
+	Vec3 dUind;
+	mutable Vec3 dUindPrev;
+
+	doublereal dXi;
+
+	bool bFlagIsFirstBlade;
+
+	doublereal dAzimuth, dAzimuthPrev;
+
+	Vec3 F, FMean, FMeanOut;
+
+	unsigned int iStepCounter;
+
+	/* data for force filtering */
+	Vec3 Uk, Uk_1, Uk_2, Yk, Yk_1, Yk_2;
+
+	unsigned int iCounter;
+	unsigned int iRotationCounter;
+
+	doublereal dpPrev, dp;
+
+	bool flag_print;
+
+public:
+	CyclocopterDMST(unsigned int uL, const DofOwner* pDO,
+		DataManager* pDM, MBDynParser& HP);
+	virtual ~CyclocopterDMST(void);
+
+	// Elaborate internal state after convergence
+	virtual void
+	AfterConvergence(const VectorHandler& X, const VectorHandler& XP);
+
+	// output; it is assumed that each element knows,
+	// by the OutputHandler, where to write its own output
+	virtual void Output(OutputHandler& OH) const;
+
+	// residual assembly
+	virtual SubVectorHandler&
+	AssRes(SubVectorHandler& WorkVec,
+		doublereal dCoef,
+		const VectorHandler& XCurr,
+		const VectorHandler& XPrimeCurr);
+
+	// Adds to the forces the contribution from an element
+	virtual void
+	AddForce(const Elem *pEl, const StructNode *pNode, const Vec3& F, const Vec3& M, const Vec3& X);
+
+	// Restores the induced velocity to an element
+	// based on the azimuth position
+	virtual Vec3 GetInducedVelocity(Elem::Type type,
+		unsigned uLabel, unsigned uPnt, const Vec3& X) const;
+
+	// Restores the induced velocity to an element
+	// based on the azimuth position (used to
+	// iterare between induced velocity calculation and
+	// calculation of aerodynamic forces
+	virtual int testfun(void)
+	{
+		std::cout <<" Test function is printing the radius" << dRadius<< std::endl ;
+		return 0;
+	};
+
+	// for the KARI induced velocity model of the cycloidal rotor)
+#if 0
+	virtual void GetInducedVelocityIter(const Vec3& X, const Vec3& T, doublereal *UindM, doublereal dTn0, doublereal dTn_dUindM) {
+		NO_OP;
+	};
+#endif
+
+	// Restores the induced velocity dalla metÃ  superiore del rotore
+	// ( only for per KARI cycloidal rotor)
+	virtual doublereal GetW(const Vec3& X) const {
+		return 0.;
+	};
+
+	virtual doublereal GetPsi(const Vec3& X) const {
+		return 0.;
+	};
+
+	virtual Mat3x3 GetRRotor(const Vec3& X) const {
+		return ::Zero3x3;
+	};
+};
+
+
+CyclocopterDMST::CyclocopterDMST(unsigned int uL, const DofOwner* pDO,
+	DataManager* pDM, MBDynParser& HP)
+: Elem(uL, flag(0)),
+CyclocopterInflow(uL, pDO),
+RRotor(::Eye3),
+dUind(::Zero3), dUindPrev(::Zero3),
+dXi(0.),
+bFlagIsFirstBlade(true),
+dAzimuth(0.), dAzimuthPrev(0.),
+F(::Zero3), FMean(::Zero3), FMeanOut(::Zero3),
+iStepCounter(0),
+Uk(::Zero3), Uk_1(::Zero3), Uk_2(::Zero3), Yk(::Zero3), Yk_1(::Zero3), Yk_2(::Zero3),
+iCounter(0), iRotationCounter(0),
+dpPrev(0.), dp(0.),
+flag_print(true)
+{
+	if (HP.IsKeyWord("help")) {
+		silent_cout(
+"									\n"
+"Module: 	Cyclocopter						\n"
+"Author: 	Pierangelo Masarati <pierangelo.masarati@DMST.it>	\n"
+"based on work by							\n"
+"		Mattia Mattaboni <mattia.mattaboni@mail.DMST.it>	\n"
+"Organization:	Dipartimento di Scienze e Tecnologie Aerospaziali	\n"
+"		Politecnico di Milano					\n"
+"		http://www.aero.DMST.it/				\n"
+" Description:	This module implements induced velocity models		\n"
+"		for cycloidal rotors.					\n"
+"									\n"
+"	All rights reserved.						\n"
+"\n"
+" Usage:\n"
+"	user element: <label> , cycloidal DMST ,\n"
+"		<aircraft_node_label> ,\n"
+"		[ orientation , (OrientationMatrix) <orientation> , ]\n"
+"		<rotor_node_label>\n"
+"		(bool) <average> ,\n"
+"		<rotor_radius> ,\n"
+"		<blade_span>\n"
+"		[ , delay , (DriveCaller) <delay> ]\n"
+"		[ , omegacut , <cut_frequency> ]\n"
+"		[ , kappa , <hover_correction_coefficient> ]\n"
+"		[ , timestep , <time_step> ]\n"
+"		[ , <output_data> ]\n"
+"	;\n"
+			<< std::endl);
+
+		if (!HP.IsArg()) {
+			/*
+			 * Exit quietly if nothing else is provided
+			 */
+			throw NoErr(MBDYN_EXCEPT_ARGS);
+		}
+
+// std::cout << "Omega " << OMEGA << std::endl;
+	}
+
+	if (!ReadRotorData(pDM, HP, uLabel, pCraft, RRot, pRotor)) {
+		throw ErrGeneric(MBDYN_EXCEPT_ARGS);
+	}
+
+	DriveCaller *pdW = 0;
+	doublereal dOmegaFilter;
+	doublereal dDeltaT;
+	if (!ReadUniform(pDM, HP, uLabel, bFlagAverage, dRadius, dSpan, pdW, dOmegaFilter, dKappa, dDeltaT, nStreamtube)) {
+		throw ErrGeneric(MBDYN_EXCEPT_ARGS);
+	}
+
+	ppRes = ReadResSets(pDM, HP);
+
+	SetOutputFlag(pDM->fReadOutput(HP, Elem::INDUCEDVELOCITY));
+
+	dArea = 2*dRadius*dSpan;
+	Weight.Set(pdW);
+
+	SetFilterCoefficients(dOmegaFilter, dDeltaT);
+}
+
+CyclocopterDMST::~CyclocopterDMST(void)
+{
+	NO_OP;
+}
+
+void
+CyclocopterDMST::AfterConvergence(const VectorHandler& X, const VectorHandler& XP)
+{
+	bFlagIsFirstBlade = true;
+	/* calculates the mean of the forces generated by the rotor over a cycle*/
+	FMean = FMean + F;;
+	iStepCounter++;
+	// if ((dAzimuth > 0. && dAzimuthPrev < 0.) || (dAzimuth < 0. && dAzimuthPrev > 0.)) {
+	if ((dAzimuth > 0. && dAzimuthPrev < 0.)) {
+		FMean = FMean/iStepCounter;
+		FMeanOut = FMean;
+		if (bFlagAverage) {
+			/* Force in the plane normal to the rotation axis */
+			doublereal dT = sqrt(FMean(2)*FMean(2) + FMean(3)*FMean(3));
+			/* Induced velocity: calculated according to dT */
+			doublereal dRho = dGetAirDensity(GetXCurr());
+			
+			#if 1
+			dUindMean = dKappa*sqrt(dT/(2*dRho*dArea));
+			/* Induced velocity components in the coordinate
+	 		* system of the rotor */
+			dUind = Zero3;
+			if (dT > std::numeric_limits<doublereal>::epsilon()) {
+				dUind(2) = dUindMean*FMean(2)/dT;
+				dUind(3) = dUindMean*FMean(3)/dT;
+			}
+			dUind(1) = (1 - dWeight)*dUind(1) + dWeight*dUindPrev(1);
+			dUind(2) = (1 - dWeight)*dUind(2) + dWeight*dUindPrev(2);
+			dUind(3) = (1 - dWeight)*dUind(3) + dWeight*dUindPrev(3);
+			/* angle by which the tension is rotated */
+			dXi = atan2(FMean(3), FMean(2)) - M_PI/2.;
+			#endif
+
+			// dUind(2) = (dT*sin(dAzimuth)*sin(dAzimuth))/(2*dRho*dRadius)*dDeltaT*
+
+			std::cout << "Radius of rotor" << std::endl ; 
+
+		}
+
+
+		FMean = Zero3;
+		iStepCounter = 0;
+	}
+
+	dAzimuthPrev = dAzimuth;
+
+	dUindPrev = dUind;
+
+	/* update the inputs and outputs of the filter */
+	Yk_2 = Yk_1;
+	Yk_1 = Yk;
+	Uk_2 = Uk_1;
+	Uk_1 = Uk;
+
+	dWeight = Weight.dGet();
+	if (dWeight < 0.) {
+		silent_cout("Rotor(" << GetLabel() << "): "
+			"delay < 0.0; using 0.0" << std::endl);
+		dWeight = 0.;
+
+	} else if (dWeight > 1.) {
+		silent_cout("Rotor(" << GetLabel() << "): "
+			"delay > 1.0; using 1.0" << std::endl);
+		dWeight = 1.;
+	}
+
+	InducedVelocity::AfterConvergence(X, XP);
+}
+int counter = 0;
+void
+CyclocopterDMST::Output(OutputHandler& OH) const
+{
+	if (bToBeOutput()) {
+			counter+=1;
+                OH.Loadable()
+                        << std::setw(8) << GetLabel()   /* 1 */
+                        << " " << RRotorTranspose*Res.Force()     /* 2-4 */
+                        << " " << RRotorTranspose*Res.Moment()    /* 5-7 */
+                        << " " << dUindMean              /* 8 */
+                        << " " << dUind                	 /* 9 -11*/
+                        << " " << dXi                	 /* 12 */
+                        << " " << dAzimuth               /* 13 */
+                        << " " << FMeanOut                	 /* 14-16 */
+                        << std::endl;
+
+                /* FIXME: check for parallel stuff ... */
+                for (int i = 0; ppRes && ppRes[i]; i++) {
+                        OH.Loadable()
+                                << std::setw(8) << GetLabel()
+                                << ":" << ppRes[i]->GetLabel()
+                                << " " << ppRes[i]->pRes->Force()
+                                << " " << ppRes[i]->pRes->Moment()
+                                << std::endl;
+                }
+               std::cout << "Output function was called" << dAzimuth*180/3.14 << std::endl; 
+		}
+}
+
+SubVectorHandler&
+CyclocopterDMST::AssRes(SubVectorHandler& WorkVec,
+	doublereal dCoef,
+	const VectorHandler& XCurr,
+	const VectorHandler& XPrimeCurr)
+{
+	// std::cout <<"testing out put    " << XCurr(1) << " " << XCurr(2) << " " << XCurr(3) << " " << XCurr(4) << " "
+	// << XCurr(5) << " " << XCurr(6) << " " << XCurr(7) << " " << XCurr(8) << " " << std::endl ;
+		/* UNIFORM induced velocity */
+	/* Transpose of the rotor rotation matrix */
+	RRotor = pCraft->GetRCurr()*RRot;
+	RRotorTranspose = RRotor.Transpose();
+	/* Force in the rotor coordinate system */
+	F = RRotorTranspose*Res.Force();
+	if (!bFlagAverage) {
+		/* filter the forces */
+		Uk = F;
+		Yk = -Yk_1*a1 - Yk_2*a2 + Uk*b0 + Uk_1*b1 + Uk_2*b2;
+		F = Yk;
+		/* Force in the plane normal to the rotation axis */
+		doublereal dT = sqrt(F(2)*F(2) + F(3)*F(3));
+
+		// std::cout << F(3) << std::endl;
+
+		/* Induced velocity: calculated according to dT */
+		doublereal dRho = dGetAirDensity(GetXCurr());
+		dUindMean = dKappa*sqrt(dT/(2*dRho*dArea));
+		/* Induced velocity components in the coordinate
+	 	* system of the rotor */
+		dUind = Zero3;
+		if (dT > std::numeric_limits<doublereal>::epsilon()) {
+			dUind(2) = dUindMean*F(2)/dT;
+			dUind(3) = dUindMean*F(3)/dT;
+		}
+		dUind(1) = (1 - dWeight)*dUind(1) + dWeight*dUindPrev(1);
+		dUind(2) = (1 - dWeight)*dUind(2) + dWeight*dUindPrev(2);
+		dUind(3) = (1 - dWeight)*dUind(3) + dWeight*dUindPrev(3);
+
+		dUindMean = sqrt(dUind(1)*dUind(1) + dUind(2)*dUind(2) + dUind(3)*dUind(3));
+		/* angle by which the tension is rotated */
+		dXi = atan2(F(3), F(2)) - M_PI/2.;
+	}
+
+	ResetForce();
+	WorkVec.Resize(0);
+
+	return WorkVec;
+}
+
+void
+CyclocopterDMST::AddForce(const Elem *pEl, const StructNode *pNode, const Vec3& F, const Vec3& M, const Vec3& X)
+{
+	/* Calculates the azimuth position of the first blade */
+	if (bFlagIsFirstBlade) {
+		Vec3 XRel(RRotorTranspose*(X - pRotor->GetXCurr()));
+		doublereal d1 = XRel(2);
+		doublereal d2 = XRel(3);
+		dAzimuth = atan2(d2, d1);
+		bFlagIsFirstBlade = false;
+
+	}
+
+	/* Calculates the moment only if output is required */
+	if (bToBeOutput()) {
+		Res.AddForces(F,M,X);
+		InducedVelocity::AddForce(pEl, pNode, F, M, X);
+
+	} else {
+		Res.AddForce(F);
+	}
+}
+
+Vec3
+CyclocopterDMST::GetInducedVelocity(Elem::Type type,
+	unsigned uLabel, unsigned uPnt, const Vec3& X) const
+{
+	Vec3 XRel(RRotorTranspose*(X - pRotor->GetXCurr()));
+
+	doublereal d1 = XRel(2);
+	doublereal d2 = XRel(3);
+
+	// std::cout <<"radius of the rotor"<< dRadius<< std::endl ;
+	/* dPsi0 is useless because the relative
+	 * angle is used: (dp-dXi)!!! */
+
+	doublereal dpp = atan2(d2, d1);
+
+	doublereal r = sqrt(d1*d1 + d2*d2)*cos(dpp - dXi);
+
+	return RRotor*((dUind*(M_PI/2.))*cos((M_PI/2.)*(r/dRadius)));
+}
+
+#if 0
+	virtual void GetInducedVelocityIter(const Vec3& X, const Vec3& T, doublereal *UindM, doublereal dTn0, doublereal dTn_dUindM) {
+		NO_OP;
+	};
+#endif
+
+/* CyclocopterDMST - end */
+
+
+
+
+
+
 #if 0 // KARI NOT IMPLEMENTED YET!
 
 /* CyclocopterKARI - begin */
@@ -1690,6 +2105,9 @@
 
 #endif // KARI NOT IMPLEMENTED YET!
 
+
+
+
 bool
 mbdyn_cyclocopter_set(void)
 {
@@ -1735,6 +2153,16 @@
 		silent_cerr("module-cyclocopter: "
 			"unable to register \"cyclocopter Polimi\""
 			<< std::endl);
+		return false;
+	}
+
+	rf = new UDERead<CyclocopterDMST>;
+	if (!SetUDE("cyclocopter" "DMST", rf)) {
+		delete rf;
+
+		silent_cerr("module-cyclocopter: "
+			"unable to register \"cyclocopter DMST\""
+			<< std::endl);
 
 		return false;
 	}
@@ -1771,3 +2199,4 @@
 }
 
 #endif // MBDYN_MODULE
+
